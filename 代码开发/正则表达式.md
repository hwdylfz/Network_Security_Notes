## 什么是正则表达式 ？

> 正则表达式是一种被用于从文本中检索符合某些特定模式的文本。

正则表达式是从左到右来匹配一个字符串的。“Regular Expression”这个词太长了，我们通常使用它的缩写“regex”或者“regexp”。 正则表达式可以被用来替换字符串中的文本、验证表单、基于模式匹配从一个字符串中提取字符串等等。 

想象一下，您正在编写应用程序，并且您希望在用户选择用户名时设置规则。我们希望用户名可以包含字母，数字，下划线和连字符。 为了让它看起来不丑，我们还想限制用户名中的字符数量。这时我们可以使用以下正则表达式来验证用户名：

[![Regular expression](assets/68747470733a2f2f692e696d6775722e636f6d2f557244623971632e706e67.png)](https://camo.githubusercontent.com/80e0fb0e4d01dbbc630a7ce35f27f352246b71ab7b8071608ea473acb4e15154/68747470733a2f2f692e696d6775722e636f6d2f557244623971632e706e67)

上面这个正则表达式可以匹配 `john_doe`，`jo-hn_doe` 和 `john12_as`。但是它不能匹配 `Jo`，因为该字符串里面包含大写字符，并且它太短了。



## 0.正则表达式速查表

| 字符          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| \             | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“`n`”匹配字符“`n`”。“`\n`”匹配一个换行符。串行“`\\`”匹配“`\`”而“`\(`”则匹配“`(`”。 |
| ^             | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“`\n`”或“`\r`”之后的位置。 |
| $             | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“`\n`”或“`\r`”之前的位置。 |
| *             | 匹配前面的子表达式零次或多次。例如，zo*能匹配“`z`”以及“`zoo`”。*等价于{0,}。 |
| +             | 匹配前面的子表达式一次或多次。例如，“`zo+`”能匹配“`zo`”以及“`zoo`”，但不能匹配“`z`”。+等价于{1,}。 |
| ?             | 匹配前面的子表达式零次或一次。例如，“`do(es)?`”可以匹配“`does`”或“`does`”中的“`do`”。?等价于{0,1}。 |
| {n}           | n是一个非负整数。匹配确定的n次。例如，“`o{2}`”不能匹配“`Bob`”中的“`o`”，但是能匹配“`food`”中的两个o。 |
| {n,}          | n是一个非负整数。至少匹配n次。例如，“`o{2,}`”不能匹配“`Bob`”中的“`o`”，但能匹配“`foooood`”中的所有o。“`o{1,}`”等价于“`o+`”。“`o{0,}`”则等价于“`o*`”。 |
| {n,m}         | m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“`o{1,3}`”将匹配“`fooooood`”中的前三个o。“`o{0,1}`”等价于“`o?`”。请注意在逗号和两个数之间不能有空格。 |
| ?             | 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“`oooo`”，“`o+?`”将匹配单个“`o`”，而“`o+`”将匹配所有“`o`”。 |
| .             | 匹配除“`\``n`”之外的任何单个字符。要匹配包括“`\``n`”在内的任何字符，请使用像“`(.|\n)`”的模式。 |
| (pattern)     | 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“`\(`”或“`\)`”。 |
| (?:pattern)   | 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(|)`”来组合一个模式的各个部分是很有用。例如“`industr(?:y|ies)`”就是一个比“`industry|industries`”更简略的表达式。 |
| (?=pattern)   | 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95|98|NT|2000)`”能匹配“`Windows2000`”中的“`Windows`”，但不能匹配“`Windows3.1`”中的“`Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| (?!pattern)   | 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95|98|NT|2000)`”能匹配“`Windows3.1`”中的“`Windows`”，但不能匹配“`Windows2000`”中的“`Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 |
| (?<=pattern)  | 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?<=95|98|NT|2000)Windows`”能匹配“`2000Windows`”中的“`Windows`”，但不能匹配“`3.1Windows`”中的“`Windows`”。 |
| (?<!pattern)  | 反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?<!95|98|NT|2000)Windows`”能匹配“`3.1Windows`”中的“`Windows`”，但不能匹配“`2000Windows`”中的“`Windows`”。 |
| x\|y          | 匹配x或y。例如，“`z|food`”能匹配“`z`”或“`food`”。“`(z|f)ood`”则匹配“`zood`”或“`food`”。 |
| [xyz]         | 字符集合。匹配所包含的任意一个字符。例如，“`[abc]`”可以匹配“`plain`”中的“`a`”。 |
| [^xyz]        | 负值字符集合。匹配未包含的任意字符。例如，“`[^abc]`”可以匹配“`plain`”中的“`p`”。 |
| [a-z]         | 字符范围。匹配指定范围内的任意字符。例如，“`[a-z]`”可以匹配“`a`”到“`z`”范围内的任意小写字母字符。 |
| [^a-z]        | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“`[^a-z]`”可以匹配任何不在“`a`”到“`z`”范围内的任意字符。 |
| \b            | 匹配一个单词边界，也就是指单词和空格间的位置。例如，“`er\b`”可以匹配“`never`”中的“`er`”，但不能匹配“`verb`”中的“`er`”。 |
| \B            | 匹配非单词边界。“`er\B`”能匹配“`verb`”中的“`er`”，但不能匹配“`never`”中的“`er`”。 |
| \cx           | 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“`c`”字符。 |
| \d            | 匹配一个数字字符。等价于[0-9]。                              |
| \D            | 匹配一个非数字字符。等价于[^0-9]。                           |
| \f            | 匹配一个换页符。等价于\x0c和\cL。                            |
| \n            | 匹配一个换行符。等价于\x0a和\cJ。                            |
| \r            | 匹配一个回车符。等价于\x0d和\cM。                            |
| \s            | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 |
| \S            | 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。                   |
| \t            | 匹配一个制表符。等价于\x09和\cI。                            |
| \v            | 匹配一个垂直制表符。等价于\x0b和\cK。                        |
| \w            | 匹配包括下划线的任何单词字符。等价于“`[A-Za-z0-9_]`”。       |
| \W            | 匹配任何非单词字符。等价于“`[^A-Za-z0-9_]`”。                |
| \xn           | 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“`\x41`”匹配“`A`”。“`\x041`”则等价于“`\x04&1`”。正则表达式中可以使用ASCII编码。. |
| \num          | 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“`(.)\1`”匹配两个连续的相同字符。 |
| \n            | 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 |
| \nm           | 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。 |
| \nml          | 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 |
| \un           | 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。 |
| \u4e00-\u9fa5 | 匹配所有中文字符                                             |

- tips:

```
// 前瞻：
exp1(?=exp2) 查找exp2前面的exp1
// 后顾：
(?<=exp2)exp1 查找exp2后面的exp1
// 负前瞻：
exp1(?!exp2) 查找后面不是exp2的exp1
// 负后顾：
(?<!exp2)exp1 查找前面不是exp2的exp1
```





## 1. 基本匹配

正则表达式只是我们用于在文本中检索字符串的模式。例如正则表达式 `cat`，表示：字母 `c` 后面跟着一个字母 `a`，再后面跟着一个字母 `t`。

```
"cat" => The cat sat on the mat
```

正则表达式 `123` 会匹配字符串“123”。通过将正则表达式中的每个字符逐个与要匹配的字符串中的每个字符进行比较，来完成正则匹配。 正则表达式通常区分大小写，因此正则表达式 `Cat` 与字符串“cat”不匹配。

```
"Cat" => The cat sat on the Cat
```

## 

## 2. 元字符

元字符是正则表达式的基本组成元素。元字符在这里跟它通常表达的意思不一样，而是以某种特殊的含义去解释。有些元字符在写在方括号内时有特殊含义。 元字符如下：

| 元字符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| .      | 匹配除换行符以外的任意字符。                                 |
| [ ]    | 字符类，匹配方括号中包含的任意字符。                         |
| [^ ]   | 否定字符类。匹配方括号中不包含的任意字符                     |
| *      | 匹配前面的子表达式零次或多次                                 |
| +      | 匹配前面的子表达式一次或多次                                 |
| ?      | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。       |
| {n,m}  | 花括号，匹配前面字符至少 n 次，但是不超过 m 次。             |
| (xyz)  | 字符组，按照确切的顺序匹配字符 xyz。                         |
| \|     | 分支结构，匹配符号之前的字符或后面的字符。                   |
| \      | 转义符，它可以还原元字符原来的含义，允许你匹配保留字符 `[ ] ( ) { } . * + ? ^ $ \ |` |
| ^      | 匹配行的开始                                                 |
| $      | 匹配行的结束                                                 |

## 

## 2.1 英文句号

英文句号 `.` 是元字符的最简单的例子。元字符 `.` 可以匹配任意单个字符。它不会匹配换行符和新行的字符。例如正则表达式 `.ar`，表示：任意字符后面跟着一个字母 `a`， 再后面跟着一个字母 `r`。

```
".ar" => The car parked in the garage.
```

## 

## 2.2 字符集

字符集也称为字符类。方括号被用于指定字符集。使用字符集内的连字符来指定字符范围。方括号内的字符范围的顺序并不重要。 例如正则表达式 `[Tt]he`，表示：大写 `T` 或小写 `t` ，后跟字母 `h`，再后跟字母 `e`。

```
"[Tt]he" => The car parked in the garage.
```

然而，字符集中的英文句号表示它字面的含义。正则表达式 `ar[.]`，表示小写字母 `a`，后面跟着一个字母 `r`，再后面跟着一个英文句号 `.` 字符。

```
"ar[.]" => A garage is a good place to park a car.
```

### 

### 2.2.1 否定字符集

一般来说插入字符 `^` 表示一个字符串的开始，但是当它在方括号内出现时，它会取消字符集。例如正则表达式 `[^c]ar`，表示：除了字母 `c` 以外的任意字符，后面跟着字符 `a`， 再后面跟着一个字母 `r`。

```
"[^c]ar" => The car parked in the garage.
```

## 

## 2.3 重复

以下元字符 `+`，`*` 或 `?` 用于指定子模式可以出现多少次。这些元字符在不同情况下的作用不同。

### 

### 2.3.1 星号

星号 `*` 表示匹配上一个匹配规则零次或多次。正则表达式 `a*` 表示小写字母 `a` 可以重复零次或者多次。但是它如果出现在字符集或者字符类之后，它表示整个字符集的重复。 例如正则表达式 `[a-z]*`，表示：一行中可以包含任意数量的小写字母。

```
"[a-z]*" => The car parked in the garage #21.
```

星号 `*` 可以与元符号 `.` 用在一起，用来匹配任意字符串 `.*`。星号 `*` 可以与空格符 `\s` 一起使用，用来匹配一串空格字符。 例如正则表达式 `\s*cat\s*`，表示：零个或多个空格，后面跟小写字母 `c`，再后面跟小写字母 `a`，再在后面跟小写字母 `t`，后面再跟零个或多个空格。

```
"\s*cat\s*" => The fat cat sat on the cat.
```

### 

### 2.3.2 加号

加号 `+` 表示匹配上一个字符一次或多次。例如正则表达式 `c.+t`，表示：一个小写字母 `c`，后跟任意数量的字符，后跟小写字母 `t`。

```
"c.+t" => The fat cat sat on the mat.
```

### 

### 2.3.3 问号

在正则表达式中，元字符 `?` 用来表示前一个字符是可选的。该符号匹配前一个字符零次或一次。 例如正则表达式 `[T]?he`，表示：可选的大写字母 `T`，后面跟小写字母 `h`，后跟小写字母 `e`。

```
"[T]he" => The car is parked in the garage.
"[T]?he" => The car is parked in the garage.
```

## 

## 2.4 花括号

在正则表达式中花括号（也被称为量词？）用于指定字符或一组字符可以重复的次数。例如正则表达式 `[0-9]{2,3}`，表示：匹配至少 2 位数字但不超过 3 位（0 到 9 范围内的字符）。

```
"[0-9]{2,3}" => The number was 9.9997 but we rounded it off to 10.0.
```

我们可以省略第二个数字。例如正则表达式 `[0-9]{2,}`，表示：匹配 2 个或更多个数字。如果我们也删除逗号，则正则表达式 `[0-9]{2}`，表示：匹配正好为 2 位数的数字。

```
"[0-9]{2,}" => The number was 9.9997 but we rounded it off to 10.0.
"[0-9]{2}" => The number was 9.9997 but we rounded it off to 10.0.
```

## 

## 2.5 字符组

字符组是一组写在圆括号内的子模式 `(...)`。正如我们在正则表达式中讨论的那样，如果我们把一个量词放在一个字符之后，它会重复前一个字符。 但是，如果我们把量词放在一个字符组之后，它会重复整个字符组。 例如正则表达式 `(ab)*` 表示匹配零个或多个的字符串“ab”。我们还可以在字符组中使用元字符 `|`。例如正则表达式 `(c|g|p)ar`，表示：小写字母 `c`、`g` 或 `p` 后面跟字母 `a`，后跟字母 `r`。

```
"(c|g|p)ar" => The car is parked in the garage.
```

## 

## 2.6 分支结构

在正则表达式中垂直条 `|` 用来定义分支结构，分支结构就像多个表达式之间的条件。现在你可能认为这个字符集和分支结构的工作方式一样。 但是字符集和分支结构巨大的区别是字符集只在字符级别上有作用，然而分支结构在表达式级别上依然可以使用。 例如正则表达式 `(T|t)he|car`，表示：匹配大写字母 `T` 或小写字母 `t`，后面跟小写字母 `h`，后跟小写字母 `e`，或匹配小写字母 `c`，后跟小写字母 `a`，后跟小写字母 `r`。

```
"(T|t)he|car" => The car is parked in the garage.
```

## 

## 2.7 转义特殊字符

正则表达式中使用反斜杠 `\` 来转义下一个字符。这将允许你使用保留字符来作为匹配字符 `{ } [ ] / \ + * . $ ^ | ?`。在特殊字符前面加 `\`，就可以使用它来做匹配字符。 例如正则表达式 `.` 是用来匹配除了换行符以外的任意字符。现在要在输入字符串中匹配 `.` 字符，正则表达式 `(f|c|m)at\.?`，表示：小写字母 `f`、`c` 或者 `m` 后跟小写字母 `a`，后跟小写字母 `t`，后跟可选的 `.` 字符。

```
"(f|c|m)at\.?" => The fat cat sat on the mat.
```

## 

## 2.8 定位符

在正则表达式中，为了检查匹配符号是否是起始符号或结尾符号，我们使用定位符。 定位符有两种类型：第一种类型是 `^` 检查匹配字符是否是起始字符，第二种类型是 `$`，它检查匹配字符是否是输入字符串的最后一个字符。

### 

### 2.8.1 插入符号

插入符号 `^` 符号用于检查匹配字符是否是输入字符串的第一个字符。如果我们使用正则表达式 `^a`（如果 a 是起始符号）匹配字符串 `abc`，它会匹配到 `a`。 但是如果我们使用正则表达式 `^b`，它是匹配不到任何东西的，因为在字符串 `abc` 中“b”不是起始字符。 让我们来看看另一个正则表达式 `^(T|t)he`，这表示：大写字母 `T` 或小写字母 `t` 是输入字符串的起始符号，后面跟着小写字母 `h`，后跟小写字母 `e`。

```
"(T|t)he" => The car is parked in the garage.
"^(T|t)he" => The car is parked in the garage.
```

### 

### 2.8.2 美元符号

美元 `$` 符号用于检查匹配字符是否是输入字符串的最后一个字符。例如正则表达式 `(at\.)$`，表示：小写字母 `a`，后跟小写字母 `t`，后跟一个 `.` 字符，且这个匹配器必须是字符串的结尾。

```
"(at\.)" => The fat cat. sat. on the mat.
"(at\.)$" => The fat cat sat on the mat.
```

## 

## 3. 简写字符集

正则表达式为常用的字符集和常用的正则表达式提供了简写。简写字符集如下：

| 简写 | 描述                                     |
| ---- | ---------------------------------------- |
| .    | 匹配除换行符以外的任意字符               |
| \w   | 匹配所有字母和数字的字符：`[a-zA-Z0-9_]` |
| \W   | 匹配非字母和数字的字符：`[^\w]`          |
| \d   | 匹配数字：`[0-9]`                        |
| \D   | 匹配非数字：`[^\d]`                      |
| \s   | 匹配空格符：`[\t\n\f\r\p{Z}]`            |
| \S   | 匹配非空格符：`[^\s]`                    |

## 

## 4. 断言

后行断言和先行断言有时候被称为断言，它们是特殊类型的 ***非捕获组***（用于匹配模式，但不包括在匹配列表中）。当我们在一种特定模式之前或者之后有这种模式时，会优先使用断言。 例如我们想获取输入字符串 `$4.44 and $10.88` 中带有前缀 `$` 的所有数字。我们可以使用这个正则表达式 `(?<=\$)[0-9\.]*`，表示：获取包含 `.` 字符且前缀为 `$` 的所有数字。 以下是正则表达式中使用的断言：

| 符号 | 描述         |
| ---- | ------------ |
| ?=   | 正向先行断言 |
| ?!   | 负向先行断言 |
| ?<=  | 正向后行断言 |
| ?<!  | 负向后行断言 |

### 

### 4.1 正向先行断言

正向先行断言认为第一部分的表达式的后面必须是先行断言表达式。返回的匹配结果仅包含与第一部分表达式匹配的文本。 要在一个括号内定义一个正向先行断言，在括号中问号和等号是这样使用的 `(?=...)`。先行断言表达式写在括号中的等号后面。 例如正则表达式 `(T|t)he(?=\sfat)`，表示：匹配大写字母 `T` 或小写字母 `t`，后面跟字母 `h`，后跟字母 `e`。 在括号中，我们定义了正向先行断言，它会引导正则表达式引擎匹配后面跟着 `fat` 的 `The` 或 `the`。

```
"(T|t)he(?=\sfat)" => The fat cat sat on the mat.
```

### 

### 4.2 负向先行断言

当我们需要指定第一部分表达式的后面不跟随某一内容时，使用负向先行断言。负向先行断言的定义跟我们定义的正向先行断言一样， 唯一的区别在于我们使用否定符号 `!` 而不是等号 `=`，例如 `(?!...)`。 我们来看看下面的正则表达式 `(T|t)he(?!\sfat)`，表示：从输入字符串中获取全部 `The` 或者 `the` 且不匹配 `fat` 前面加上一个空格字符。

```
"(T|t)he(?!\sfat)" => The fat cat sat on the mat.
```

### 

### 4.3 正向后行断言

正向后行断言用于获取跟随在特定模式之后的所有匹配内容。正向后行断言表示为 `(?<=...)`。例如正则表达式 `(?<=(T|t)he\s)(fat|mat)`，表示：从输入字符串中获取在单词 `The` 或 `the` 之后的所有 `fat` 和 `mat` 单词。

```
"(?<=(T|t)he\s)(fat|mat)" => The fat cat sat on the mat.
```

### 

### 4.4 负向后行断言

负向后行断言是用于获取不跟随在特定模式之后的所有匹配的内容。负向后行断言表示为 `(?<!...)`。例如正则表达式 `(?<!(T|t)he\s)(cat)`，表示：在输入字符中获取所有不在 `The` 或 `the` 之后的所有单词 `cat`。

```
"(?<!(T|t)he\s)(cat)" => The cat sat on cat.
```

## 

## 5. 标记

标记也称为修饰符，因为它会修改正则表达式的输出。这些标志可以以任意顺序或组合使用，并且是正则表达式的一部分。

| 标记 | 描述                                       |
| ---- | ------------------------------------------ |
| i    | 不区分大小写：将匹配设置为不区分大小写。   |
| g    | 全局搜索：搜索整个输入字符串中的所有匹配。 |
| m    | 多行匹配：会匹配输入字符串每一行。         |

### 

### 5.1 不区分大小写

`i` 修饰符用于执行不区分大小写匹配。例如正则表达式 `/The/gi`，表示：大写字母 `T`，后跟小写字母 `h`，后跟字母 `e`。 但是在正则匹配结束时 `i` 标记会告诉正则表达式引擎忽略这种情况。正如你所看到的，我们还使用了 `g` 标记，因为我们要在整个输入字符串中搜索匹配。

```
"The" => The fat cat sat on the mat.
"/The/gi" => The fat cat sat on the mat.
```

### 

### 5.2 全局搜索

`g` 修饰符用于执行全局匹配（会查找所有匹配，不会在查找到第一个匹配时就停止）。 例如正则表达式 `/.(at)/g`，表示：除换行符之外的任意字符，后跟小写字母 `a`，后跟小写字母 `t`。 因为我们在正则表达式的末尾使用了 `g` 标记，它会从整个输入字符串中找到每个匹配项。

```
".(at)" => The fat cat sat on the mat.
"/.(at)/g" => The fat cat sat on the mat.
```

### 

### 5.3 多行匹配

`m` 修饰符被用来执行多行的匹配。正如我们前面讨论过的 `(^, $)`，使用定位符来检查匹配字符是输入字符串开始或者结束。但是我们希望每一行都使用定位符，所以我们就使用 `m` 修饰符。 例如正则表达式 `/at(.)?$/gm`，表示：小写字母 `a`，后跟小写字母 `t`，匹配除了换行符以外任意字符零次或一次。而且因为 `m` 标记，现在正则表达式引擎匹配字符串中每一行的末尾。

```
"/.at(.)?$/" => The fat
                cat sat
                on the mat.
"/.at(.)?$/gm" => The fat
                  cat sat
                  on the mat.
```

## 

## 常用正则表达式

- **正整数**：`^\d+$`
- **负整数**：`^-\d+$`
- **电话号码**：`^+?[\d\s]{3,}$`
- **电话代码**：`^+?[\d\s]+(?[\d\s]{10,}$`
- **整数**：`^-?\d+$`
- **用户名**：`^[\w\d_.]{4,16}$`
- **字母数字字符**：`^[a-zA-Z0-9]*$`
- **带空格的字母数字字符**：`^[a-zA-Z0-9 ]*$`
- **密码**：`^(?=^.{6,}$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$`
- **电子邮件**：`^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4})*$`
- **IPv4 地址**：`^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$`
- **小写字母**：`^([a-z])*$`
- **大写字母**：`^([A-Z])*$`
- **网址**：`^(((http|https|ftp):\/\/)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]]){2,4}([[a-zA-Z0-9]\/+=%&_\.~?\-]*))*$`
- **VISA 信用卡号码**：`^(4[0-9]{12}(?:[0-9]{3})?)*$`
- **日期（MM/DD/YYYY）**：`^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2}$`
- **日期（YYYY/MM/DD）**：`^(19|20)?[0-9]{2}[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$`
- **万事达信用卡号码**：`^(5[1-5][0-9]{14})*$`

